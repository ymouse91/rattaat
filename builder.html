<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Rattaat – Pulmaeditori</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(255,255,255,.06);
    --text:#e9eefc;
    --muted:rgba(233,238,252,.70);

    --gridGap:8px;
    --cell:56px;

    --t:#7c4dff; /* violetti */
    --p:#ff4fae; /* pinkki */
    --r:#ff3b30; /* punainen */
    --o:#ff9500; /* oranssi */
    --s:#4aa3ff; /* sininen */
    --k:#ffd60a; /* keltainen */
    --v:#33d17a; /* vihreä */
  }

  html,body{height:100%;}
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 50% -20%, rgba(93,120,255,.25), transparent 55%),
                radial-gradient(900px 600px at 20% 0%, rgba(255,80,180,.18), transparent 50%),
                var(--bg);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    overflow-x:hidden;
    -webkit-user-select:none;
    user-select:none;
    touch-action:manipulation;
  }

  .app{
    max-width:1100px;
    margin:0 auto;
    padding:16px 12px 20px;
  }

  .topbar{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    margin-bottom:12px;
    flex-wrap:wrap;
  }
  .title{display:flex;flex-direction:column;gap:6px;min-width:260px;flex:1;}
  h1{margin:0;font-size:19px;letter-spacing:.2px;}
  .sub{font-size:12.5px;color:var(--muted);line-height:1.25;}

  .btnrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end;}
  button{
    border:0;border-radius:12px;background:rgba(255,255,255,.12);
    color:var(--text);padding:10px 12px;font-weight:750;cursor:pointer;
    box-shadow: 0 8px 22px rgba(0,0,0,.25);
  }
  button:hover{ background:rgba(255,255,255,.16); }
  button:active{ transform: translateY(1px); }
  button.secondary{ background:rgba(255,255,255,.08); font-weight:650; }
  button.danger{ background: rgba(255,90,90,.16); }

  .layout{display:grid;grid-template-columns: 1fr; gap:14px;}
  @media (min-width: 980px){
    .layout{ grid-template-columns: 520px 1fr; align-items:start; }
  }

  /* ====== BOARD ====== */
  .boardWrap{
    display:flex;align-items:center;justify-content:center;
    padding:12px 8px;background:var(--panel);
    border-radius:18px;box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }
  .boardStage{
    position:relative;
    padding:14px;border-radius:18px;
    background: rgba(255,255,255,.03);
    outline: 1px solid rgba(255,255,255,.10);
  }
  .grid{
    display:grid;
    grid-template-columns: repeat(5, var(--cell));
    grid-template-rows: repeat(5, var(--cell));
    gap:var(--gridGap);
    padding:10px;border-radius:18px;
    background: rgba(255,255,255,.05);
    outline: 1px solid rgba(255,255,255,.12);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.18);
  }

  .cell{
    width:var(--cell);height:var(--cell);
    border-radius:16px;background: rgba(255,255,255,.04);
    outline:1px solid rgba(255,255,255,.10);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.15);
    position:relative;cursor:pointer;overflow:hidden;
  }
  .cell:hover{ outline-color: rgba(255,255,255,.18); }

  .cell .dot{
    position:absolute;inset:0;display:grid;place-items:center;
    opacity:.55;pointer-events:none;
  }
  .peg{
    width:10px;height:10px;border-radius:50%;
    background: rgba(255,255,255,.10);
    outline: 2px solid rgba(0,0,0,.25);
    box-shadow: 0 3px 6px rgba(0,0,0,.25);
  }

  .part{position:absolute;inset:0;display:grid;place-items:center;}
  .chip{
    width:84%;height:84%;border-radius:16px;
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.18), 0 10px 18px rgba(0,0,0,.18);
    position:relative;display:grid;place-items:center;
  }
  .chip.noGear::after{
    content:"";position:absolute;width:28px;height:28px;border-radius:50%;
    background: radial-gradient(circle, rgba(0,0,0,.30) 0 35%, transparent 36%),
                radial-gradient(circle, rgba(255,255,255,.18) 0 55%, transparent 56%),
                rgba(255,255,255,.07);
    outline:1px solid rgba(0,0,0,.20);
    opacity:.28;
  }
  .chip.gear::after{
    content:"";position:absolute;width:34px;height:34px;border-radius:50%;
    background:
      radial-gradient(circle, rgba(0,0,0,.35) 0 30%, transparent 31%),
      conic-gradient(from 0deg,
        rgba(223,231,255,.9) 0 10deg, transparent 10deg 25deg,
        rgba(223,231,255,.9) 25deg 35deg, transparent 35deg 50deg,
        rgba(223,231,255,.9) 50deg 60deg, transparent 60deg 75deg,
        rgba(223,231,255,.9) 75deg 85deg, transparent 85deg 100deg,
        rgba(223,231,255,.9) 100deg 110deg, transparent 110deg 125deg,
        rgba(223,231,255,.9) 125deg 135deg, transparent 135deg 150deg,
        rgba(223,231,255,.9) 150deg 160deg, transparent 160deg 175deg,
        rgba(223,231,255,.9) 175deg 185deg, transparent 185deg 200deg,
        rgba(223,231,255,.9) 200deg 210deg, transparent 210deg 225deg,
        rgba(223,231,255,.9) 225deg 235deg, transparent 235deg 250deg,
        rgba(223,231,255,.9) 250deg 260deg, transparent 260deg 275deg,
        rgba(223,231,255,.9) 275deg 285deg, transparent 285deg 300deg,
        rgba(223,231,255,.9) 300deg 310deg, transparent 310deg 325deg,
        rgba(223,231,255,.9) 325deg 335deg, transparent 335deg 350deg,
        rgba(223,231,255,.9) 350deg 360deg
      );
    mask: radial-gradient(circle, transparent 0 35%, #000 36% 100%);
    outline: 2px solid rgba(0,0,0,.25);
    box-shadow: 0 6px 10px rgba(0,0,0,.22);
  }

  /* ====== BIG GEARS (positioned by JS) ====== */
  .gearBig{
    position:absolute;
    border-radius:50%;
    display:grid;place-items:center;
    background:
      radial-gradient(circle at 50% 50%, rgba(0,0,0,.35) 0 32%, transparent 33%),
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18) 0 48%, transparent 49%),
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.07) 0 63%, transparent 64%),
      rgba(255,255,255,.05);
    outline: 2px solid rgba(255,255,255,.14);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.18), 0 10px 22px rgba(0,0,0,.25);
    pointer-events:none;
    opacity:.95;
  }
  .gearBig::before{
    content:"";
    width:72%;height:72%;
    border-radius:50%;
    background:
      conic-gradient(from 0deg,
        rgba(223,231,255,.65) 0 8deg, transparent 8deg 22deg,
        rgba(223,231,255,.65) 22deg 30deg, transparent 30deg 45deg,
        rgba(223,231,255,.65) 45deg 53deg, transparent 53deg 67deg,
        rgba(223,231,255,.65) 67deg 75deg, transparent 75deg 90deg,
        rgba(223,231,255,.65) 90deg 98deg, transparent 98deg 112deg,
        rgba(223,231,255,.65) 112deg 120deg, transparent 120deg 135deg,
        rgba(223,231,255,.65) 135deg 143deg, transparent 143deg 157deg,
        rgba(223,231,255,.65) 157deg 165deg, transparent 165deg 180deg,
        rgba(223,231,255,.65) 180deg 188deg, transparent 188deg 202deg,
        rgba(223,231,255,.65) 202deg 210deg, transparent 210deg 225deg,
        rgba(223,231,255,.65) 225deg 233deg, transparent 233deg 247deg,
        rgba(223,231,255,.65) 247deg 255deg, transparent 255deg 270deg,
        rgba(223,231,255,.65) 270deg 278deg, transparent 278deg 292deg,
        rgba(223,231,255,.65) 292deg 300deg, transparent 300deg 315deg,
        rgba(223,231,255,.65) 315deg 323deg, transparent 323deg 337deg,
        rgba(223,231,255,.65) 337deg 345deg, transparent 345deg 360deg
      );
    mask: radial-gradient(circle, transparent 0 42%, #000 43% 100%);
    opacity:.9;
  }

  /* ====== RIGHT PANEL ====== */
  .panel{
    background:var(--panel);
    border-radius:18px;
    padding:12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }

  .row{
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    margin-bottom:10px;
  }

  label{font-size:12px; color:var(--muted);}
  input[type="text"]{
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.10);
    color:var(--text);
    border-radius:12px;
    padding:10px 12px;
    font-weight:650;
    outline:none;
    min-width: 240px;
    flex:1;
  }

  select{
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    color:var(--text);
    border-radius:12px;
    padding:10px 12px;
    font-weight:650;
    outline:none;
    min-width: 260px;
    flex:1;
  }

  .status{
    font-size:13px;
    font-weight:850;
    white-space:nowrap;
  }

  .help{
    font-size:12.5px; color:var(--muted); line-height:1.25;
    margin-top:6px;
  }

  /* ====== PIECE TRAY ====== */
  .pieceRows{display:flex;flex-direction:column;gap:10px; margin-top:12px;}
  .pieceRow{display:grid;gap:10px;}
  .pieceRow.row3{ grid-template-columns: repeat(3, minmax(92px, 1fr)); }
  .pieceRow.row4{ grid-template-columns: repeat(4, minmax(92px, 1fr)); }

  .pieceCard{
    background: rgba(255,255,255,.05);
    border-radius:16px;
    padding:10px;
    outline:1px solid rgba(255,255,255,.10);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.12);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }
  .thumb{
    width:78px;
    height:64px;
    border-radius:14px;
    background: rgba(0,0,0,.18);
    outline:1px solid rgba(255,255,255,.10);
    display:grid;
    place-items:center;
    cursor:pointer;
    position:relative;
    overflow:hidden;
  }
  .thumb.selected{
    outline:2px solid rgba(223,231,255,.55);
    box-shadow: 0 0 0 4px rgba(90,120,255,.12);
  }
  .thumb.used{ opacity:.35; filter:saturate(.7); }
  .thumb svg{ width:100%; height:100%; }

  .mirrorBtn{
    width:78px;
    padding:8px 10px;
    border-radius:12px;
    font-weight:850;
    font-size:12px;
    background: rgba(255,255,255,.08);
    box-shadow: 0 8px 18px rgba(0,0,0,.18);
  }

  @media (max-width:520px){
    :root{ --cell:48px; --gridGap:7px; }
    .thumb{ width:74px; height:62px; }
    .mirrorBtn{ width:74px; }
  }
  @media (max-width:380px){
    .pieceRow.row3{ grid-template-columns: repeat(1, minmax(150px, 1fr)); }
    .pieceRow.row4{ grid-template-columns: repeat(1, minmax(150px, 1fr)); }
  }
</style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="title">
      <h1>Rattaat – Pulmaeditori</h1>
      <div class="sub">
        Miniatyyrin klikkaus: valitse / (toinen klikkaus samaan) käännä 90°. Peilaa vain t/p/r/v.
        Ruutua klikkaamalla aseta, palan päältä klikkaamalla poista. Tallenna → uusi pulma heti perään.
      </div>
    </div>
    <div class="btnrow">
      <button id="btnExport" class="secondary">Tallenna JSON</button>
      <button id="btnImport" class="secondary">Tuo JSON</button>
      <input id="fileIn" type="file" accept=".json,application/json" style="display:none" />
    </div>
  </div>

  <div class="layout">
    <div class="boardWrap">
      <div id="boardStage" class="boardStage">
        <div id="grid" class="grid" aria-label="pelialue"></div>
        <div id="gearA" class="gearBig" aria-hidden="true"></div>
        <div id="gearB" class="gearBig" aria-hidden="true"></div>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <label for="puzSelect">Pulma</label>
        <select id="puzSelect"></select>
      </div>

      <div class="row">
        <label for="puzName">Nimi</label>
        <input id="puzName" type="text" placeholder="esim. Starter 01" />
      </div>

      <div class="row">
        <button id="btnSave">Tallenna → Uusi pulma</button>
        <button id="btnNew" class="secondary">Uusi tyhjä</button>
        <button id="btnClear" class="secondary">Tyhjennä lauta</button>
        <button id="btnDelete" class="danger">Poista pulma</button>
      </div>

      <div class="row" style="justify-content:space-between;">
        <div class="status" id="status">Valitse pala.</div>
        <div class="status" id="count">0/7</div>
      </div>

      <div class="help">
        Tallennusmuoto: palojen {id, rot, mirror, anchor}. anchor on 1–25 (vas→oik, ylh→alas).
        Iso rattaat ovat aina ruudun 10 oikealla ja ruudun 22 alapuolella (bigGears: [10,22]).
      </div>

      <div id="pieces" class="pieceRows"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const W = 5, H = 5;

  // Iso rattaat ovat ruudun 10 ja 22 vieressä.
  // 1..25: 10 => (r=1,c=4), 22 => (r=4,c=1)
  const BIG_A_TOUCH = { r:1, c:4 };
  const BIG_B_TOUCH = { r:4, c:1 };

  const PIECES = {
    t: ["ox","-o"],
    p: ["xo","-x"],
    r: ["-xo","xo-"],
    o: ["oxx"],
    s: ["-x-","ooo"],
    k: ["-o-","xxx"],
    v: ["--x","xxo"]
  };

  const NO_MIRROR = new Set(["o","s","k", "t", "p"]);
  const HAS_MIRROR = new Set(["r","v"]);

  const COLORS = {
    t: css("--t"),
    p: css("--p"),
    r: css("--r"),
    o: css("--o"),
    s: css("--s"),
    k: css("--k"),
    v: css("--v")
  };

  // ===== Builder puzzle file format =====
  // { format, game, version, board:{w,h,bigGears}, puzzles:[ {id,name,pieces:[...]} ] }
  const FILE_TEMPLATE = () => ({
    format: "rattaat_puzzles",
    game: "Rattaat",
    version: 1,
    board: { w:5, h:5, bigGears:[10,22] },
    puzzles: []
  });

  let fileObj = FILE_TEMPLATE();

  // ===== state for current board editing =====
  const state = {};
  for (const id of Object.keys(PIECES)) {
    state[id] = { id, rot: 0, mir: false, placed: null };
  }
  let selectedId = null;

  // ===== UI refs =====
  const boardStageEl = document.getElementById("boardStage");
  const gridEl = document.getElementById("grid");
  const piecesEl = document.getElementById("pieces");
  const statusEl = document.getElementById("status");
  const countEl = document.getElementById("count");

  const puzSelectEl = document.getElementById("puzSelect");
  const puzNameEl = document.getElementById("puzName");

  const gearAEl = document.getElementById("gearA");
  const gearBEl = document.getElementById("gearB");

  // ===== build grid =====
  const cells = [];
  gridEl.innerHTML = "";
  for (let r=0; r<H; r++){
    for (let c=0; c<W; c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.r = r;
      cell.dataset.c = c;

      const dot = document.createElement("div");
      dot.className = "dot";
      dot.innerHTML = `<div class="peg"></div>`;
      cell.appendChild(dot);

      cell.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        onCellClick(r,c);
      });

      gridEl.appendChild(cell);
      cells.push(cell);
    }
  }

  // ===== buttons =====
  document.getElementById("btnClear").addEventListener("click", () => {
    clearBoardOnly();
    renderBoard();
    renderTray();
    refreshCounts();
    setStatus("Tyhjennetty lauta.");
  });

  document.getElementById("btnNew").addEventListener("click", () => {
    createNewPuzzle(true);
  });

  document.getElementById("btnSave").addEventListener("click", () => {
    saveCurrentPuzzleAndCreateNext();
  });

  document.getElementById("btnDelete").addEventListener("click", () => {
    deleteCurrentPuzzle();
  });

  document.getElementById("btnExport").addEventListener("click", () => {
    exportJSON();
  });

  document.getElementById("btnImport").addEventListener("click", () => {
    document.getElementById("fileIn").click();
  });

  document.getElementById("fileIn").addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    e.target.value = "";
    if (!f) return;
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      importJSON(obj);
    }catch(err){
      alert("JSON ei aukea: " + err.message);
    }
  });

  puzSelectEl.addEventListener("change", () => {
    const idx = +puzSelectEl.value;
    loadPuzzleToBoard(idx);
  });

  puzNameEl.addEventListener("input", () => {
    const idx = getCurrentPuzzleIndex();
    if (idx < 0) return;
    fileObj.puzzles[idx].name = puzNameEl.value.trim();
    refreshPuzzleSelectOptions(idx);
  });

  window.addEventListener("resize", () => requestAnimationFrame(placeBigGears));

  // ===== init: start with 1 empty puzzle =====
  createNewPuzzle(false); // creates first puzzle and loads it
  renderTray();
  renderBoard();
  placeBigGears();
  refreshCounts();
  setStatus("Valitse pala.");

  // ===== Core: placement and rendering =====
  function css(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  function parseBaseShape(grid){
    const occ = [];
    for (let y=0; y<grid.length; y++){
      const row = grid[y];
      for (let x=0; x<row.length; x++){
        const ch = row[x];
        if (ch !== "-"){
          occ.push({ x, y, gear: ch === "x" });
        }
      }
    }
    return { occ, w: grid[0].length, h: grid.length };
  }

  function transformOcc(base, rot, mir){
    let pts = base.occ.map(p => ({ x:p.x, y:p.y, gear:p.gear }));

    if (mir){
      pts = pts.map(p => ({ ...p, x: (base.w - 1) - p.x }));
    }

    let W0 = base.w, H0 = base.h;

    if (rot === 90){
      pts = pts.map(p => ({ ...p, x: p.y, y: (W0 - 1) - p.x }));
      [W0,H0] = [H0,W0];
    }else if (rot === 180){
      pts = pts.map(p => ({ ...p, x: (W0 - 1) - p.x, y: (H0 - 1) - p.y }));
    }else if (rot === 270){
      pts = pts.map(p => ({ ...p, x: (H0 - 1) - p.y, y: p.x }));
      [W0,H0] = [H0,W0];
    }

    let minX = Infinity, minY = Infinity;
    for (const p of pts){
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
    }
    pts = pts.map(p => ({ ...p, x: p.x - minX, y: p.y - minY }));

    let maxX = 0, maxY = 0;
    for (const p of pts){
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return { pts, w: maxX + 1, h: maxY + 1 };
  }

  function pieceCellsOnBoard(pid, placement){
    const base = parseBaseShape(PIECES[pid]);
    const tr = transformOcc(base, state[pid].rot, state[pid].mir);
    const out = [];
    for (const p of tr.pts){
      const r = placement.anchorR + p.y;
      const c = placement.anchorC + p.x;
      out.push({ r, c, gear: p.gear });
    }
    return out;
  }

  function buildOccupancyMap(){
    const map = new Map();
    for (const pid of Object.keys(state)){
      const pl = state[pid].placed;
      if (!pl) continue;
      for (const cell of pieceCellsOnBoard(pid, pl)){
        const k = cell.r + "," + cell.c;
        map.set(k, { pid, gear: cell.gear });
      }
    }
    return map;
  }

  function findPieceAt(r,c, occMap){
    const k = r + "," + c;
    const v = occMap.get(k);
    return v ? v.pid : null;
  }

  function smartPlaceAt(pid, r, c, occMap){
    const base = parseBaseShape(PIECES[pid]);
    const tr = transformOcc(base, state[pid].rot, state[pid].mir);

    const pts = [...tr.pts].sort((a,b) => (a.y - b.y) || (a.x - b.x));
    const candidates = [];

    for (const p of pts){
      const anchorR = r - p.y;
      const anchorC = c - p.x;

      let ok = true;
      for (const q of tr.pts){
        const rr = anchorR + q.y;
        const cc = anchorC + q.x;
        if (rr < 0 || cc < 0 || rr >= H || cc >= W) { ok = false; break; }
        const k = rr + "," + cc;
        if (occMap.has(k)) { ok = false; break; }
      }
      if (ok) candidates.push({ anchorR, anchorC });
    }

    if (!candidates.length) return null;
    candidates.sort((a,b) => (a.anchorR - b.anchorR) || (a.anchorC - b.anchorC));
    return candidates[0];
  }

  function onCellClick(r,c){
    const occMap = buildOccupancyMap();
    const hit = findPieceAt(r,c, occMap);

    if (hit){
      state[hit].placed = null;
      renderBoard(); renderTray(); refreshCounts();
      setStatus("Poistettiin pala.");
      return;
    }

    if (!selectedId){
      setStatus("Valitse pala.");
      return;
    }

    const pid = selectedId;
    if (state[pid].placed){
      setStatus("Pala on jo laudalla (poista klikkaamalla sitä).");
      return;
    }

    const placement = smartPlaceAt(pid, r, c, occMap);
    if (!placement){
      setStatus("Ei mahdu tuohon. Käännä/peilaa tai valitse toinen ruutu.");
      return;
    }

    state[pid].placed = placement;
    renderBoard(); renderTray(); refreshCounts();
    setStatus("Asetettu.");
  }

  function renderBoard(){
    const occMap = buildOccupancyMap();

    for (let r=0; r<H; r++){
      for (let c=0; c<W; c++){
        const cellEl = cells[r*W + c];
        const old = cellEl.querySelector(".part");
        if (old) old.remove();

        const k = r + "," + c;
        const v = occMap.get(k);
        if (!v) continue;

        const pid = v.pid;
        const isGear = v.gear;

        const part = document.createElement("div");
        part.className = "part";

        const chip = document.createElement("div");
        chip.className = "chip " + (isGear ? "gear" : "noGear");
        chip.style.background = COLORS[pid];
        chip.style.opacity = "0.95";

        part.appendChild(chip);
        cellEl.appendChild(part);
      }
    }

    requestAnimationFrame(placeBigGears);
  }

  function renderTray(){
    piecesEl.innerHTML = "";

    const rowTop = document.createElement("div");
    rowTop.className = "pieceRow row3";

    const rowBottom = document.createElement("div");
    rowBottom.className = "pieceRow row4";

    const topIds = ["o","s","k"];
    const bottomIds = ["t","p","r","v"];

    for (const pid of topIds) rowTop.appendChild(renderPieceCard(pid, false));
    for (const pid of bottomIds) rowBottom.appendChild(renderPieceCard(pid, true));

    piecesEl.appendChild(rowTop);
    piecesEl.appendChild(rowBottom);
  }

  function renderPieceCard(pid, showMirror){
    const card = document.createElement("div");
    card.className = "pieceCard";

    const thumb = document.createElement("div");
    thumb.className = "thumb";
    if (pid === selectedId) thumb.classList.add("selected");
    if (state[pid].placed) thumb.classList.add("used");
    thumb.title = "Klikkaa: valitse / pyöräytä 90°";

    thumb.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      onThumbClick(pid);
    });

    thumb.appendChild(renderThumbSVG(pid));
    card.appendChild(thumb);

    if (showMirror && HAS_MIRROR.has(pid)){
      const btn = document.createElement("button");
      btn.className = "mirrorBtn";
      btn.textContent = "Peilaa";
      btn.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        onMirror(pid);
      });
      card.appendChild(btn);
    }

    return card;
  }

  function renderThumbSVG(pid){
    const base = parseBaseShape(PIECES[pid]);
    const tr = transformOcc(base, state[pid].rot, state[pid].mir);

    const pad = 8;
    const cell = 18;
    const w = tr.w * cell + pad*2;
    const h = tr.h * cell + pad*2;

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

    const bg = document.createElementNS(svgNS, "rect");
    bg.setAttribute("x", "0"); bg.setAttribute("y", "0");
    bg.setAttribute("width", w); bg.setAttribute("height", h);
    bg.setAttribute("rx", "14");
    bg.setAttribute("fill", "rgba(255,255,255,.06)");
    bg.setAttribute("stroke", "rgba(255,255,255,.10)");
    svg.appendChild(bg);

    for (const p of tr.pts){
      const x = pad + p.x*cell;
      const y = pad + p.y*cell;

      const rr = document.createElementNS(svgNS, "rect");
      rr.setAttribute("x", x);
      rr.setAttribute("y", y);
      rr.setAttribute("width", cell-2);
      rr.setAttribute("height", cell-2);
      rr.setAttribute("rx", "6");
      rr.setAttribute("fill", COLORS[pid]);
      rr.setAttribute("opacity", state[pid].placed ? "0.35" : "0.92");
      rr.setAttribute("stroke", "rgba(0,0,0,.25)");
      rr.setAttribute("stroke-width", "1");
      svg.appendChild(rr);

      const cc = document.createElementNS(svgNS, "circle");
      cc.setAttribute("cx", x + (cell-2)/2);
      cc.setAttribute("cy", y + (cell-2)/2);
      cc.setAttribute("r", p.gear ? "6.2" : "4.8");
      cc.setAttribute("fill", p.gear ? "rgba(223,231,255,.92)" : "rgba(0,0,0,.22)");
      cc.setAttribute("opacity", p.gear ? "1" : "0.35");
      svg.appendChild(cc);
    }
    return svg;
  }

  function onThumbClick(pid){
    if (selectedId !== pid){
      selectedId = pid;
      renderTray();
      refreshCounts();
      setStatus("Valittu pala.");
      return;
    }
  state[pid].rot = (state[pid].rot - 90 + 360) % 360;
    renderTray();
    setStatus("Käännetty 90°.");
  }

  function onMirror(pid){
    if (NO_MIRROR.has(pid)) return;
    state[pid].mir = !state[pid].mir;
    selectedId = pid;
    renderTray();
    setStatus("Peilattu.");
  }

  // ===== Big gears placement (exact cell alignment) =====
  function cellRectFor(r,c){
    const el = cells[r*W + c];
    return el.getBoundingClientRect();
  }

  function placeBigGears(){
    const stageRect = boardStageEl.getBoundingClientRect();
    const gap = parseFloat(css("--gridGap")) || 8;
    const cellSize = parseFloat(css("--cell")) || 56;
    const size = cellSize * 0.92;

    // A: ruudun 10 oikealla puolella
    const a = cellRectFor(BIG_A_TOUCH.r, BIG_A_TOUCH.c);
    const aCenterY = a.top + a.height/2;
    const aLeft = (a.right - stageRect.left) + gap;
    const aTop  = (aCenterY - stageRect.top) - size/2;

    // B: ruudun 22 alapuolella
    const b = cellRectFor(BIG_B_TOUCH.r, BIG_B_TOUCH.c);
    const bCenterX = b.left + b.width/2;
    const bLeft = (bCenterX - stageRect.left) - size/2;
    const bTop  = (b.bottom - stageRect.top) + gap;

    gearAEl.style.width = size + "px";
    gearAEl.style.height = size + "px";
    gearAEl.style.left = aLeft + "px";
    gearAEl.style.top  = aTop + "px";

    gearBEl.style.width = size + "px";
    gearBEl.style.height = size + "px";
    gearBEl.style.left = bLeft + "px";
    gearBEl.style.top  = bTop + "px";
  }

  // ===== Puzzle list & editing =====
  function createNewPuzzle(selectIt){
    const nextId = makeNextId();
    const puz = {
      id: nextId,
      name: "Pulma " + nextId,
      pieces: []
    };
    fileObj.puzzles.push(puz);
    refreshPuzzleSelectOptions(fileObj.puzzles.length - 1);
    if (selectIt){
      puzSelectEl.value = String(fileObj.puzzles.length - 1);
      loadPuzzleToBoard(fileObj.puzzles.length - 1);
    }else{
      // first puzzle
      puzSelectEl.value = "0";
      loadPuzzleToBoard(0);
    }
  }

  function makeNextId(){
    // id muotoa "001", "002", ...
    const n = fileObj.puzzles.length + 1;
    return String(n).padStart(3, "0");
  }

  function refreshPuzzleSelectOptions(selectIndex){
    puzSelectEl.innerHTML = "";
    fileObj.puzzles.forEach((p, i) => {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = `${p.id} – ${p.name || ""}`.trim();
      puzSelectEl.appendChild(opt);
    });
    const idx = (selectIndex != null) ? selectIndex : getCurrentPuzzleIndex();
    if (idx >= 0 && idx < fileObj.puzzles.length){
      puzSelectEl.value = String(idx);
    }
  }

  function getCurrentPuzzleIndex(){
    const v = puzSelectEl.value;
    const idx = (v === "" ? -1 : +v);
    return Number.isFinite(idx) ? idx : -1;
  }

  function loadPuzzleToBoard(idx){
    if (idx < 0 || idx >= fileObj.puzzles.length) return;
    const puz = fileObj.puzzles[idx];

    // reset
    clearBoardOnly();
    for (const pid of Object.keys(state)){
      state[pid].rot = 0;
      state[pid].mir = false;
    }
    selectedId = null;

    // apply
    for (const p of (puz.pieces || [])){
      if (!state[p.id]) continue;
      state[p.id].rot = ((p.rot % 360) + 360) % 360;
      state[p.id].mir = !!p.mirror;

      const a = (p.anchor|0);
      if (a >= 1 && a <= 25){
        const z = a - 1;
        const r = Math.floor(z / W);
        const c = z % W;
        state[p.id].placed = { anchorR:r, anchorC:c };
      }
    }

    puzNameEl.value = puz.name || "";
    renderBoard();
    renderTray();
    refreshCounts();
    setStatus("Pulma ladattu muokattavaksi.");
  }

  function clearBoardOnly(){
    for (const pid of Object.keys(state)){
      state[pid].placed = null;
    }
  }

  function boardToPuzzlePieces(){
    // tallennetaan vain laudalla olevat palat
    const out = [];
    for (const pid of Object.keys(state)){
      const st = state[pid];
      if (!st.placed) continue;

      // anchor on palan placed.anchorR/C top-left (kuten pelissä)
      const anchor = st.placed.anchorR * W + st.placed.anchorC + 1; // 1..25
      out.push({
        id: pid,
        rot: st.rot,
        mirror: !!st.mir,
        anchor
      });
    }
    // vakiojärjestys
    out.sort((a,b) => a.id.localeCompare(b.id));
    return out;
  }

  function saveCurrentPuzzleAndCreateNext(){
    const idx = getCurrentPuzzleIndex();
    if (idx < 0) return;

    const puz = fileObj.puzzles[idx];
    puz.name = puzNameEl.value.trim() || puz.name || ("Pulma " + puz.id);
    puz.pieces = boardToPuzzlePieces();

    refreshPuzzleSelectOptions(idx);

    // pyydetty toiminto: "kun uusi pulma tallennetaan niin luodaan heti uusi pulma"
    createNewPuzzle(true);
    setStatus("Tallennettu. Uusi pulma luotu.");
  }

  function deleteCurrentPuzzle(){
    const idx = getCurrentPuzzleIndex();
    if (idx < 0) return;

    if (fileObj.puzzles.length === 1){
      // pidetään aina vähintään 1 pulma
      fileObj.puzzles[0] = { id:"001", name:"Pulma 001", pieces:[] };
      refreshPuzzleSelectOptions(0);
      loadPuzzleToBoard(0);
      setStatus("Pulma tyhjennetty (viimeistä ei poisteta).");
      return;
    }

    fileObj.puzzles.splice(idx, 1);

    // renumeroi id:t siististi 001..N (helpottaa)
    fileObj.puzzles.forEach((p, i) => {
      p.id = String(i+1).padStart(3, "0");
      if (!p.name) p.name = "Pulma " + p.id;
    });

    const newIdx = Math.max(0, idx - 1);
    refreshPuzzleSelectOptions(newIdx);
    loadPuzzleToBoard(newIdx);
    setStatus("Pulma poistettu.");
  }

  // ===== Export / Import =====
  function exportJSON(){
    // päivitä current puzzle name valikossa (jos käyttäjä kirjoittaa mutta ei vaihtanut)
    const idx = getCurrentPuzzleIndex();
    if (idx >= 0){
      fileObj.puzzles[idx].name = puzNameEl.value.trim() || fileObj.puzzles[idx].name;
      refreshPuzzleSelectOptions(idx);
    }

    const json = JSON.stringify(fileObj, null, 2);
    const blob = new Blob([json], { type:"application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "rattaat_pulmat.json";
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus("JSON ladattu.");
  }

  function importJSON(obj){
    // kevyt validointi
    if (!obj || typeof obj !== "object") { alert("JSON on tyhjä tai väärä."); return; }
    if (!Array.isArray(obj.puzzles)) { alert("JSON: puzzles puuttuu."); return; }

    // hyväksytään, mutta pakotetaan board asetukset tähän peliin
    fileObj = {
      ...FILE_TEMPLATE(),
      ...obj,
      board: { w:5, h:5, bigGears:[10,22] },
      puzzles: obj.puzzles.map((p, i) => ({
        id: (p.id ? String(p.id) : String(i+1).padStart(3,"0")),
        name: (p.name ? String(p.name) : ("Pulma " + String(i+1).padStart(3,"0"))),
        pieces: Array.isArray(p.pieces) ? p.pieces : []
      }))
    };

    if (fileObj.puzzles.length === 0){
      fileObj.puzzles.push({ id:"001", name:"Pulma 001", pieces:[] });
    }

    // siisti id:t 001..N
    fileObj.puzzles.forEach((p, i) => p.id = String(i+1).padStart(3,"0"));

    refreshPuzzleSelectOptions(0);
    loadPuzzleToBoard(0);
    setStatus("JSON tuotu. Voit muokata ja tallentaa.");
  }

  // ===== UI helpers =====
  function refreshCounts(){
    const placed = Object.keys(state).filter(pid => !!state[pid].placed).length;
    countEl.textContent = `${placed}/7`;
    // status label stays in statusEl
  }

  function setStatus(txt){
    statusEl.textContent = txt;
  }
})();
</script>
</body>
</html>
