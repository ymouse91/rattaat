<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Rattaat – Pulmaeditori</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(255,255,255,.06);
    --text:#e9eefc;
    --muted:rgba(233,238,252,.70);

    --gridGap:8px;
    --cell:56px;

    --t:#7c4dff; /* violetti */
    --p:#ff4fae; /* pinkki */
    --r:#ff3b30; /* punainen */
    --o:#ff9500; /* oranssi */
    --s:#4aa3ff; /* sininen */
    --k:#ffd60a; /* keltainen */
    --v:#33d17a; /* vihreä */
  }

  html,body{height:100%;}
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 50% -20%, rgba(93,120,255,.25), transparent 55%),
                radial-gradient(900px 600px at 20% 0%, rgba(255,80,180,.18), transparent 50%),
                var(--bg);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    overflow-x:hidden;
    -webkit-user-select:none;
    user-select:none;
    touch-action:manipulation;
  }

  .app{
    max-width:1100px;
    margin:0 auto;
    padding:16px 12px 20px;
  }

  .topbar{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    margin-bottom:12px;
    flex-wrap:wrap;
  }
  .title{display:flex;flex-direction:column;gap:6px;min-width:260px;flex:1;}
  h1{margin:0;font-size:19px;letter-spacing:.2px;}
  .sub{font-size:12.5px;color:var(--muted);line-height:1.25;}

  .btnrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end;}
  button{
    border:0;border-radius:12px;background:rgba(255,255,255,.12);
    color:var(--text);padding:10px 12px;font-weight:750;cursor:pointer;
    box-shadow: 0 8px 22px rgba(0,0,0,.25);
  }
  button:hover{ background:rgba(255,255,255,.16); }
  button:active{ transform: translateY(1px); }
  button.secondary{ background:rgba(255,255,255,.08); font-weight:650; }
  button.danger{ background: rgba(255,90,90,.16); }
  button.check{ background: rgba(90,255,90,.16); }
  
  .layout{display:grid;grid-template-columns: 1fr; gap:14px;}
  @media (min-width: 980px){
    .layout{ grid-template-columns: 520px 1fr; align-items:start; }
  }

  /* ====== BOARD ====== */
  .boardWrap{
    display:flex;align-items:center;justify-content:center;
    padding:12px 8px;background:var(--panel);
    border-radius:18px;box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }
  .boardStage{
    position:relative;
    padding:14px;border-radius:18px;
    background: rgba(255,255,255,.03);
    outline: 1px solid rgba(255,255,255,.10);
  }
  .grid{
    display:grid;
    grid-template-columns: repeat(5, var(--cell));
    grid-template-rows: repeat(5, var(--cell));
    gap:var(--gridGap);
    padding:10px;border-radius:18px;
    background: rgba(255,255,255,.05);
    outline: 1px solid rgba(255,255,255,.12);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.18);
  }

  .cell{
    width:var(--cell);height:var(--cell);
    border-radius:16px;background: rgba(255,255,255,.04);
    outline:1px solid rgba(255,255,255,.10);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.15);
    position:relative;cursor:pointer;overflow:hidden;
  }
  .cell:hover{ outline-color: rgba(255,255,255,.18); }

  .cell .dot{
    position:absolute;inset:0;display:grid;place-items:center;
    opacity:.55;pointer-events:none;
  }
  .peg{
    width:10px;height:10px;border-radius:50%;
    background: rgba(255,255,255,.10);
    outline: 2px solid rgba(0,0,0,.25);
    box-shadow: 0 3px 6px rgba(0,0,0,.25);
  }

  .part{position:absolute;inset:0;display:grid;place-items:center;}
  .chip{
    width:84%;height:84%;border-radius:16px;
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.18), 0 10px 18px rgba(0,0,0,.18);
    position:relative;display:grid;place-items:center;
  }
  .chip.noGear::after{
    content:"";position:absolute;width:28px;height:28px;border-radius:50%;
    background: radial-gradient(circle, rgba(0,0,0,.30) 0 35%, transparent 36%),
                radial-gradient(circle, rgba(255,255,255,.18) 0 55%, transparent 56%),
                rgba(255,255,255,.07);
    outline:1px solid rgba(0,0,0,.20);
    opacity:.28;
  }
  .chip.gear::after{
    content:"";position:absolute;width:34px;height:34px;border-radius:50%;
    background:
      radial-gradient(circle, rgba(0,0,0,.35) 0 30%, transparent 31%),
      conic-gradient(from 0deg,
        rgba(223,231,255,.9) 0 10deg, transparent 10deg 25deg,
        rgba(223,231,255,.9) 25deg 35deg, transparent 35deg 50deg,
        rgba(223,231,255,.9) 50deg 60deg, transparent 60deg 75deg,
        rgba(223,231,255,.9) 75deg 85deg, transparent 85deg 100deg,
        rgba(223,231,255,.9) 100deg 110deg, transparent 110deg 125deg,
        rgba(223,231,255,.9) 125deg 135deg, transparent 135deg 150deg,
        rgba(223,231,255,.9) 150deg 160deg, transparent 160deg 175deg,
        rgba(223,231,255,.9) 175deg 185deg, transparent 185deg 200deg,
        rgba(223,231,255,.9) 200deg 210deg, transparent 210deg 225deg,
        rgba(223,231,255,.9) 225deg 235deg, transparent 235deg 250deg,
        rgba(223,231,255,.9) 250deg 260deg, transparent 260deg 275deg,
        rgba(223,231,255,.9) 275deg 285deg, transparent 285deg 300deg,
        rgba(223,231,255,.9) 300deg 310deg, transparent 310deg 325deg,
        rgba(223,231,255,.9) 325deg 335deg, transparent 335deg 350deg,
        rgba(223,231,255,.9) 350deg 360deg
      );
    mask: radial-gradient(circle, transparent 0 35%, #000 36% 100%);
    outline: 2px solid rgba(0,0,0,.25);
    box-shadow: 0 6px 10px rgba(0,0,0,.22);
  }

  /* ====== BIG GEARS (positioned by JS) ====== */
  .gearBig{
    position:absolute;
    border-radius:50%;
    display:grid;place-items:center;
    background:
      radial-gradient(circle at 50% 50%, rgba(0,0,0,.35) 0 32%, transparent 33%),
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18) 0 48%, transparent 49%),
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.07) 0 63%, transparent 64%),
      rgba(255,255,255,.05);
    outline: 2px solid rgba(255,255,255,.14);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.18), 0 10px 22px rgba(0,0,0,.25);
    pointer-events:none;
    opacity:.95;
  }
  .gearBig::before{
    content:"";
    width:72%;height:72%;
    border-radius:50%;
    background:
      conic-gradient(from 0deg,
        rgba(223,231,255,.65) 0 8deg, transparent 8deg 22deg,
        rgba(223,231,255,.65) 22deg 30deg, transparent 30deg 45deg,
        rgba(223,231,255,.65) 45deg 53deg, transparent 53deg 67deg,
        rgba(223,231,255,.65) 67deg 75deg, transparent 75deg 90deg,
        rgba(223,231,255,.65) 90deg 98deg, transparent 98deg 112deg,
        rgba(223,231,255,.65) 112deg 120deg, transparent 120deg 135deg,
        rgba(223,231,255,.65) 135deg 143deg, transparent 143deg 157deg,
        rgba(223,231,255,.65) 157deg 165deg, transparent 165deg 180deg,
        rgba(223,231,255,.65) 180deg 188deg, transparent 188deg 202deg,
        rgba(223,231,255,.65) 202deg 210deg, transparent 210deg 225deg,
        rgba(223,231,255,.65) 225deg 233deg, transparent 233deg 247deg,
        rgba(223,231,255,.65) 247deg 255deg, transparent 255deg 270deg,
        rgba(223,231,255,.65) 270deg 278deg, transparent 278deg 292deg,
        rgba(223,231,255,.65) 292deg 300deg, transparent 300deg 315deg,
        rgba(223,231,255,.65) 315deg 323deg, transparent 323deg 337deg,
        rgba(223,231,255,.65) 337deg 345deg, transparent 345deg 360deg
      );
    mask: radial-gradient(circle, transparent 0 42%, #000 43% 100%);
    opacity:.9;
  }

  /* ====== RIGHT PANEL ====== */
  .panel{
    background:var(--panel);
    border-radius:18px;
    padding:12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }

  .row{
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    margin-bottom:10px;
  }

  label{font-size:12px; color:var(--muted);}
  input[type="text"]{
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.10);
    color:var(--text);
    border-radius:12px;
    padding:10px 12px;
    font-weight:650;
    outline:none;
    min-width: 240px;
    flex:1;
  }

  select{
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    color:var(--text);
    border-radius:12px;
    padding:10px 12px;
    font-weight:650;
    outline:none;
    min-width: 260px;
    flex:1;
  }

  .status{
    font-size:13px;
    font-weight:850;
    white-space:nowrap;
  }

  .help{
    font-size:12.5px; color:var(--muted); line-height:1.25;
    margin-top:6px;
  }


/* Suljettu select */
#puzSelect{
  background: #1f2933;
  color: #e5e7eb;
  border: 1px solid #374151;
}

/* Avattu lista (Chrome / PC) */
#puzSelect option{
  background-color: #1f2933;
  color: #e5e7eb;
}

/* Hover-valinta */
#puzSelect option:checked,
#puzSelect option:hover{
  background-color: #374151;
  color: #ffffff;
}

  /* ====== PIECE TRAY ====== */
  .pieceRows{display:flex;flex-direction:column;gap:10px; margin-top:12px;}
  .pieceRow{display:grid;gap:10px;}
  .pieceRow.row3{ grid-template-columns: repeat(3, minmax(92px, 1fr)); }
  .pieceRow.row4{ grid-template-columns: repeat(4, minmax(92px, 1fr)); }

  .pieceCard{
    background: rgba(255,255,255,.05);
    border-radius:16px;
    padding:10px;
    outline:1px solid rgba(255,255,255,.10);
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.12);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }
  .thumb{
    width:78px;
    height:64px;
    border-radius:14px;
    background: rgba(0,0,0,.18);
    outline:1px solid rgba(255,255,255,.10);
    display:grid;
    place-items:center;
    cursor:pointer;
    position:relative;
    overflow:hidden;
  }
  .thumb.selected{
    outline:2px solid rgba(223,231,255,.55);
    box-shadow: 0 0 0 4px rgba(90,120,255,.12);
  }
  .thumb.used{ opacity:.35; filter:saturate(.7); }
  .thumb svg{ width:100%; height:100%; }

  .mirrorBtn{
    width:78px;
    padding:8px 10px;
    border-radius:12px;
    font-weight:850;
    font-size:12px;
    background: rgba(255,255,255,.08);
    box-shadow: 0 8px 18px rgba(0,0,0,.18);
  }

  @media (max-width:520px){
    :root{ --cell:48px; --gridGap:7px; }
    .thumb{ width:74px; height:62px; }
    .mirrorBtn{ width:74px; }
  }
  @media (max-width:380px){
    .pieceRow.row3{ grid-template-columns: repeat(1, minmax(150px, 1fr)); }
    .pieceRow.row4{ grid-template-columns: repeat(1, minmax(150px, 1fr)); }
  }
  
  #status{
    min-height: 170px;     /* varataan tila ettei UI hypi */
    white-space: pre-line; /* rivinvaihdot näkyviin */
    line-height: 1.4;
  }

</style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="title">
      <h1>Rattaat – Pulmaeditori</h1>
      <div class="sub">
        Miniatyyrin klikkaus: valitse / (toinen klikkaus samaan) käännä 90°. Peilaa vain t/p/r/v.
        Ruutua klikkaamalla aseta, palan päältä klikkaamalla poista. Tallenna → uusi pulma heti perään.
      </div>
    </div>
    <div class="btnrow">
      <button id="btnExport" class="secondary">Tallenna JSON</button>
      <button id="btnImport" class="secondary">Tuo JSON</button>
      <input id="fileIn" type="file" accept=".json,application/json" style="display:none" />
    </div>
  </div>

  <div class="layout">
    <div class="boardWrap">
      <div id="boardStage" class="boardStage">
        <div id="grid" class="grid" aria-label="pelialue"></div>
        <div id="gearA" class="gearBig" aria-hidden="true"></div>
        <div id="gearB" class="gearBig" aria-hidden="true"></div>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <label for="puzSelect">Pulma</label>
        <select id="puzSelect"></select>
      </div>

      <div class="row">
        <label for="puzName">Nimi</label>
        <input id="puzName" type="text" placeholder="esim. Starter 01" />
      </div>

      <div class="row">
        <button id="btnSave">Tallenna → Uusi pulma</button>

        <button id="btnNew" class="secondary">Uusi tyhjä</button>
        <button id="btnClear" class="secondary">Tyhjennä lauta</button>
        <button id="btnDelete" class="danger">Poista pulma</button>
		<button id="btnSolve" class="check">Tarkista ratkaistavuus</button>
      </div>

      <div class="row" style="justify-content:space-between;">
        <div class="status" id="status">Valitse pala.</div>
        <div class="status" id="count">0/7</div>
      </div>

      <div class="help">
        Tallennusmuoto: palojen {id, rot, mirror, anchor}. anchor on 1–25 (vas→oik, ylh→alas).
        Iso rattaat ovat aina ruudun 10 oikealla ja ruudun 22 alapuolella (bigGears: [10,22]).
      </div>

      <div id="pieces" class="pieceRows"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const W = 5, H = 5;

  // Iso rattaat ovat ruudun 10 ja 22 vieressä.
  // 1..25: 10 => (r=1,c=4), 22 => (r=4,c=1)
  const BIG_A_TOUCH = { r:1, c:4 };
  const BIG_B_TOUCH = { r:4, c:1 };

  const PIECES = {
    t: ["ox","-o"],
    p: ["xo","-x"],
    r: ["-xo","xo-"],
    o: ["oxx"],
    s: ["-x-","ooo"],
    k: ["-o-","xxx"],
    v: ["--x","xxo"]
  };

  const NO_MIRROR = new Set(["o","s","k", "t", "p"]);
  const HAS_MIRROR = new Set(["r","v"]);

  const COLORS = {
    t: css("--t"),
    p: css("--p"),
    r: css("--r"),
    o: css("--o"),
    s: css("--s"),
    k: css("--k"),
    v: css("--v")
  };

  // ===== Builder puzzle file format =====
  // { format, game, version, board:{w,h,bigGears}, puzzles:[ {id,name,pieces:[...]} ] }
  const FILE_TEMPLATE = () => ({
    format: "rattaat_puzzles",
    game: "Rattaat",
    version: 1,
    board: { w:5, h:5, bigGears:[10,22] },
    puzzles: []
  });

  let fileObj = FILE_TEMPLATE();

  // Last computed solver metrics for the currently loaded puzzle (saved on Save/Export)
  let lastSolveMetrics = null;

  function formatMetricsLines(m){
    if(!m) return null;
    const lines = [];
    // Summary
    if(m.solvable === false || m.solutions === 0){
      lines.push("❌ Ei ratkaisua (0 kpl)");
    }else if(m.unique){
      lines.push("✅ Löytyi ratkaisu (uniikki)");
      lines.push("   (1 kpl)");
    }else{
      lines.push("✅ Löytyi useampi ratkaisu");
      lines.push("   (2+ kpl)");
    }

    lines.push("");
    lines.push("Mittarit:");
    if(typeof m.nodes === "number") lines.push(`• Solmut: ${m.nodes}`);
    if(typeof m.backtracks === "number") lines.push(`• Backtrackit: ${m.backtracks}`);
    if(typeof m.decoys === "number") lines.push(`• Näennäisratkaisut: ${m.decoys}`);
    if(typeof m.gearAdjacentCandidates === "number") lines.push(`• Ratassopivat asennot: ${m.gearAdjacentCandidates}`);
    lines.push(`• Alkuhaarat: ${m.firstChoices == null ? "-" : m.firstChoices}`);
    return lines;
  }

  function invalidateMetrics(){
    lastSolveMetrics = null;
    const idx = getCurrentPuzzleIndex();
    if(idx >= 0 && idx < fileObj.puzzles.length){
      fileObj.puzzles[idx].metrics = null;
    }
  }


  // ===== state for current board editing =====
  const state = {};
  for (const id of Object.keys(PIECES)) {
    state[id] = { id, rot: 0, mir: false, placed: null };
  }
  let selectedId = null;

  // ===== UI refs =====
  const boardStageEl = document.getElementById("boardStage");
  const gridEl = document.getElementById("grid");
  const piecesEl = document.getElementById("pieces");
  const statusEl = document.getElementById("status");
  const countEl = document.getElementById("count");

  const puzSelectEl = document.getElementById("puzSelect");
  const puzNameEl = document.getElementById("puzName");

  const gearAEl = document.getElementById("gearA");
  const gearBEl = document.getElementById("gearB");

  // ===== build grid =====
  const cells = [];
  gridEl.innerHTML = "";
  for (let r=0; r<H; r++){
    for (let c=0; c<W; c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.r = r;
      cell.dataset.c = c;

      const dot = document.createElement("div");
      dot.className = "dot";
      dot.innerHTML = `<div class="peg"></div>`;
      cell.appendChild(dot);

      cell.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        onCellClick(r,c);
      });

      gridEl.appendChild(cell);
      cells.push(cell);
    }
  }

  // ===== buttons =====
  document.getElementById("btnClear").addEventListener("click", () => {
    invalidateMetrics();
    clearBoardOnly();
    renderBoard();
    renderTray();
    refreshCounts();
    setStatus("Tyhjennetty lauta.");
  });

  document.getElementById("btnNew").addEventListener("click", () => {
    createNewPuzzle(true);
  });

  document.getElementById("btnSave").addEventListener("click", () => {
    saveCurrentPuzzleAndCreateNext();
  });

  document.getElementById("btnSolve").addEventListener("click", () => {
    checkSolvableCurrentBoard();
  });

  document.getElementById("btnDelete").addEventListener("click", () => {
    deleteCurrentPuzzle();
  });

  document.getElementById("btnExport").addEventListener("click", () => {
    exportJSON();
  });

  document.getElementById("btnImport").addEventListener("click", () => {
    document.getElementById("fileIn").click();
  });

  document.getElementById("fileIn").addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    e.target.value = "";
    if (!f) return;
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      importJSON(obj);
    }catch(err){
      alert("JSON ei aukea: " + err.message);
    }
  });

  puzSelectEl.addEventListener("change", () => {
    const idx = +puzSelectEl.value;
    loadPuzzleToBoard(idx);
  });

  puzNameEl.addEventListener("input", () => {
    const idx = getCurrentPuzzleIndex();
    if (idx < 0) return;
    fileObj.puzzles[idx].name = puzNameEl.value.trim();
    refreshPuzzleSelectOptions(idx);
  });

  window.addEventListener("resize", () => requestAnimationFrame(placeBigGears));

  // ===== init: start with 1 empty puzzle =====
  createNewPuzzle(false); // creates first puzzle and loads it
  renderTray();
  renderBoard();
  placeBigGears();
  refreshCounts();
  setStatus("Valitse pala.");

  // ===== Core: placement and rendering =====
  function css(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  function parseBaseShape(grid){
    const occ = [];
    for (let y=0; y<grid.length; y++){
      const row = grid[y];
      for (let x=0; x<row.length; x++){
        const ch = row[x];
        if (ch !== "-"){
          occ.push({ x, y, gear: ch === "x" });
        }
      }
    }
    return { occ, w: grid[0].length, h: grid.length };
  }

  function transformOcc(base, rot, mir){
    let pts = base.occ.map(p => ({ x:p.x, y:p.y, gear:p.gear }));

    if (mir){
      pts = pts.map(p => ({ ...p, x: (base.w - 1) - p.x }));
    }

    let W0 = base.w, H0 = base.h;

    if (rot === 90){
      pts = pts.map(p => ({ ...p, x: p.y, y: (W0 - 1) - p.x }));
      [W0,H0] = [H0,W0];
    }else if (rot === 180){
      pts = pts.map(p => ({ ...p, x: (W0 - 1) - p.x, y: (H0 - 1) - p.y }));
    }else if (rot === 270){
      pts = pts.map(p => ({ ...p, x: (H0 - 1) - p.y, y: p.x }));
      [W0,H0] = [H0,W0];
    }

    let minX = Infinity, minY = Infinity;
    for (const p of pts){
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
    }
    pts = pts.map(p => ({ ...p, x: p.x - minX, y: p.y - minY }));

    let maxX = 0, maxY = 0;
    for (const p of pts){
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return { pts, w: maxX + 1, h: maxY + 1 };
  }

  function pieceCellsOnBoard(pid, placement){
    const base = parseBaseShape(PIECES[pid]);
    const tr = transformOcc(base, state[pid].rot, state[pid].mir);
    const out = [];
    for (const p of tr.pts){
      const r = placement.anchorR + p.y;
      const c = placement.anchorC + p.x;
      out.push({ r, c, gear: p.gear });
    }
    return out;
  }

  function buildOccupancyMap(){
    const map = new Map();
    for (const pid of Object.keys(state)){
      const pl = state[pid].placed;
      if (!pl) continue;
      for (const cell of pieceCellsOnBoard(pid, pl)){
        const k = cell.r + "," + cell.c;
        map.set(k, { pid, gear: cell.gear });
      }
    }
    return map;
  }

  function findPieceAt(r,c, occMap){
    const k = r + "," + c;
    const v = occMap.get(k);
    return v ? v.pid : null;
  }

  function smartPlaceAt(pid, r, c, occMap){
    const base = parseBaseShape(PIECES[pid]);
    const tr = transformOcc(base, state[pid].rot, state[pid].mir);

    const pts = [...tr.pts].sort((a,b) => (a.y - b.y) || (a.x - b.x));
    const candidates = [];

    for (const p of pts){
      const anchorR = r - p.y;
      const anchorC = c - p.x;

      let ok = true;
      for (const q of tr.pts){
        const rr = anchorR + q.y;
        const cc = anchorC + q.x;
        if (rr < 0 || cc < 0 || rr >= H || cc >= W) { ok = false; break; }
        const k = rr + "," + cc;
        if (occMap.has(k)) { ok = false; break; }
      }
      if (ok) candidates.push({ anchorR, anchorC });
    }

    if (!candidates.length) return null;
    candidates.sort((a,b) => (a.anchorR - b.anchorR) || (a.anchorC - b.anchorC));
    return candidates[0];
  }

  function onCellClick(r,c){
    const occMap = buildOccupancyMap();
    const hit = findPieceAt(r,c, occMap);

    if (hit){
      invalidateMetrics();
      state[hit].placed = null;
      renderBoard(); renderTray(); refreshCounts();
      setStatus("Poistettiin pala.");
      return;
    }

    if (!selectedId){
      setStatus("Valitse pala.");
      return;
    }

    const pid = selectedId;
    if (state[pid].placed){
      setStatus("Pala on jo laudalla (poista klikkaamalla sitä).");
      return;
    }

    const placement = smartPlaceAt(pid, r, c, occMap);
    if (!placement){
      setStatus("Ei mahdu tuohon. Käännä/peilaa tai valitse toinen ruutu.");
      return;
    }

    state[pid].placed = placement;
    invalidateMetrics();
    renderBoard(); renderTray(); refreshCounts();
    setStatus("Asetettu.");
  }

  function renderBoard(){
    const occMap = buildOccupancyMap();

    for (let r=0; r<H; r++){
      for (let c=0; c<W; c++){
        const cellEl = cells[r*W + c];
        const old = cellEl.querySelector(".part");
        if (old) old.remove();

        const k = r + "," + c;
        const v = occMap.get(k);
        if (!v) continue;

        const pid = v.pid;
        const isGear = v.gear;

        const part = document.createElement("div");
        part.className = "part";

        const chip = document.createElement("div");
        chip.className = "chip " + (isGear ? "gear" : "noGear");
        chip.style.background = COLORS[pid];
        chip.style.opacity = "0.95";

        part.appendChild(chip);
        cellEl.appendChild(part);
      }
    }

    requestAnimationFrame(placeBigGears);
  }

  function renderTray(){
    piecesEl.innerHTML = "";

    const rowTop = document.createElement("div");
    rowTop.className = "pieceRow row3";

    const rowBottom = document.createElement("div");
    rowBottom.className = "pieceRow row4";

    const topIds = ["o","s","k"];
    const bottomIds = ["t","p","r","v"];

    for (const pid of topIds) rowTop.appendChild(renderPieceCard(pid, false));
    for (const pid of bottomIds) rowBottom.appendChild(renderPieceCard(pid, true));

    piecesEl.appendChild(rowTop);
    piecesEl.appendChild(rowBottom);
  }

  function renderPieceCard(pid, showMirror){
    const card = document.createElement("div");
    card.className = "pieceCard";

    const thumb = document.createElement("div");
    thumb.className = "thumb";
    if (pid === selectedId) thumb.classList.add("selected");
    if (state[pid].placed) thumb.classList.add("used");
    thumb.title = "Klikkaa: valitse / pyöräytä 90°";

    thumb.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      onThumbClick(pid);
    });

    thumb.appendChild(renderThumbSVG(pid));
    card.appendChild(thumb);

    if (showMirror && HAS_MIRROR.has(pid)){
      const btn = document.createElement("button");
      btn.className = "mirrorBtn";
      btn.textContent = "Peilaa";
      btn.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        onMirror(pid);
      });
      card.appendChild(btn);
    }

    return card;
  }

  function renderThumbSVG(pid){
    const base = parseBaseShape(PIECES[pid]);
    const tr = transformOcc(base, state[pid].rot, state[pid].mir);

    const pad = 8;
    const cell = 18;
    const w = tr.w * cell + pad*2;
    const h = tr.h * cell + pad*2;

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

    const bg = document.createElementNS(svgNS, "rect");
    bg.setAttribute("x", "0"); bg.setAttribute("y", "0");
    bg.setAttribute("width", w); bg.setAttribute("height", h);
    bg.setAttribute("rx", "14");
    bg.setAttribute("fill", "rgba(255,255,255,.06)");
    bg.setAttribute("stroke", "rgba(255,255,255,.10)");
    svg.appendChild(bg);

    for (const p of tr.pts){
      const x = pad + p.x*cell;
      const y = pad + p.y*cell;

      const rr = document.createElementNS(svgNS, "rect");
      rr.setAttribute("x", x);
      rr.setAttribute("y", y);
      rr.setAttribute("width", cell-2);
      rr.setAttribute("height", cell-2);
      rr.setAttribute("rx", "6");
      rr.setAttribute("fill", COLORS[pid]);
      rr.setAttribute("opacity", state[pid].placed ? "0.35" : "0.92");
      rr.setAttribute("stroke", "rgba(0,0,0,.25)");
      rr.setAttribute("stroke-width", "1");
      svg.appendChild(rr);

      const cc = document.createElementNS(svgNS, "circle");
      cc.setAttribute("cx", x + (cell-2)/2);
      cc.setAttribute("cy", y + (cell-2)/2);
      cc.setAttribute("r", p.gear ? "6.2" : "4.8");
      cc.setAttribute("fill", p.gear ? "rgba(223,231,255,.92)" : "rgba(0,0,0,.22)");
      cc.setAttribute("opacity", p.gear ? "1" : "0.35");
      svg.appendChild(cc);
    }
    return svg;
  }

  function onThumbClick(pid){
    if (selectedId !== pid){
      selectedId = pid;
      renderTray();
      refreshCounts();
      setStatus("Valittu pala.");
      return;
    }
    // Myötäpäivään kuten itse pelissä
    state[pid].rot = (state[pid].rot + 90) % 360;
    if(state[pid].placed){
      invalidateMetrics();
      renderBoard();
    }
    renderTray();
    setStatus("Käännetty 90°.");
  }

  function onMirror(pid){
    if (NO_MIRROR.has(pid)) return;
    state[pid].mir = !state[pid].mir;
    selectedId = pid;
    if(state[pid].placed){
      invalidateMetrics();
      renderBoard();
    }
    renderTray();
    setStatus("Peilattu.");
  }

  // ===== Big gears placement (exact cell alignment) =====
  function cellRectFor(r,c){
    const el = cells[r*W + c];
    return el.getBoundingClientRect();
  }

  function placeBigGears(){
    const stageRect = boardStageEl.getBoundingClientRect();
    const gap = parseFloat(css("--gridGap")) || 8;
    const cellSize = parseFloat(css("--cell")) || 56;
    const size = cellSize * 0.92;

    // A: ruudun 10 oikealla puolella
    const a = cellRectFor(BIG_A_TOUCH.r, BIG_A_TOUCH.c);
    const aCenterY = a.top + a.height/2;
    const aLeft = (a.right - stageRect.left) + gap;
    const aTop  = (aCenterY - stageRect.top) - size/2;

    // B: ruudun 22 alapuolella
    const b = cellRectFor(BIG_B_TOUCH.r, BIG_B_TOUCH.c);
    const bCenterX = b.left + b.width/2;
    const bLeft = (bCenterX - stageRect.left) - size/2;
    const bTop  = (b.bottom - stageRect.top) + gap;

    gearAEl.style.width = size + "px";
    gearAEl.style.height = size + "px";
    gearAEl.style.left = aLeft + "px";
    gearAEl.style.top  = aTop + "px";

    gearBEl.style.width = size + "px";
    gearBEl.style.height = size + "px";
    gearBEl.style.left = bLeft + "px";
    gearBEl.style.top  = bTop + "px";
  }

  // ===== Puzzle list & editing =====
  function createNewPuzzle(selectIt){
    const nextId = makeNextId();
    const puz = {
      id: nextId,
      name: "Pulma " + nextId,
      pieces: [],
      metrics: null
    };
    fileObj.puzzles.push(puz);
    refreshPuzzleSelectOptions(fileObj.puzzles.length - 1);
    if (selectIt){
      puzSelectEl.value = String(fileObj.puzzles.length - 1);
      loadPuzzleToBoard(fileObj.puzzles.length - 1);
    }else{
      // first puzzle
      puzSelectEl.value = "0";
      loadPuzzleToBoard(0);
    }
  }

  function makeNextId(){
    // id muotoa "001", "002", ...
    const n = fileObj.puzzles.length + 1;
    return String(n).padStart(3, "0");
  }

  function refreshPuzzleSelectOptions(selectIndex){
    puzSelectEl.innerHTML = "";
    fileObj.puzzles.forEach((p, i) => {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = `${p.id} – ${p.name || ""}`.trim();
      puzSelectEl.appendChild(opt);
    });
    const idx = (selectIndex != null) ? selectIndex : getCurrentPuzzleIndex();
    if (idx >= 0 && idx < fileObj.puzzles.length){
      puzSelectEl.value = String(idx);
    }
  }

  function getCurrentPuzzleIndex(){
    const v = puzSelectEl.value;
    const idx = (v === "" ? -1 : +v);
    return Number.isFinite(idx) ? idx : -1;
  }

  function loadPuzzleToBoard(idx){
    if (idx < 0 || idx >= fileObj.puzzles.length) return;
    const puz = fileObj.puzzles[idx];

    // Keep any previously computed metrics with the puzzle (may be null)
    lastSolveMetrics = (puz.metrics != null) ? puz.metrics : null;

    // reset
    clearBoardOnly();
    for (const pid of Object.keys(state)){
      state[pid].rot = 0;
      state[pid].mir = false;
    }
    selectedId = null;

    // apply
    for (const p of (puz.pieces || [])){
      if (!state[p.id]) continue;
      state[p.id].rot = ((p.rot % 360) + 360) % 360;
      state[p.id].mir = !!p.mirror;

      const a = (p.anchor|0);
      if (a >= 1 && a <= 25){
        const z = a - 1;
        const r = Math.floor(z / W);
        const c = z % W;
        state[p.id].placed = { anchorR:r, anchorC:c };
      }
    }

    puzNameEl.value = puz.name || "";
    renderBoard();
    renderTray();
    refreshCounts();
    const mLines = formatMetricsLines(lastSolveMetrics);
    if(mLines){
      setStatus(["Pulma ladattu (metrics tallennettu).", "", ...mLines].join("\n"));
    }else{
      setStatus("Pulma ladattu muokattavaksi.");
    }
  }

  function clearBoardOnly(){
    for (const pid of Object.keys(state)){
      state[pid].placed = null;
    }
  }

  function boardToPuzzlePieces(){
    // tallennetaan vain laudalla olevat palat
    const out = [];
    for (const pid of Object.keys(state)){
      const st = state[pid];
      if (!st.placed) continue;

      // anchor on palan placed.anchorR/C top-left (kuten pelissä)
      const anchor = st.placed.anchorR * W + st.placed.anchorC + 1; // 1..25
      out.push({
        id: pid,
        rot: st.rot,
        mirror: !!st.mir,
        anchor
      });
    }
    // vakiojärjestys
    out.sort((a,b) => a.id.localeCompare(b.id));
    return out;
  }

  function saveCurrentPuzzleAndCreateNext(){
    const idx = getCurrentPuzzleIndex();
    if (idx < 0) return;

    const puz = fileObj.puzzles[idx];
    puz.name = puzNameEl.value.trim() || puz.name || ("Pulma " + puz.id);
    puz.pieces = boardToPuzzlePieces();


    // Save computed metrics (or keep empty if not computed)
    puz.metrics = (lastSolveMetrics != null) ? { ...lastSolveMetrics } : (puz.metrics != null ? puz.metrics : null);

    refreshPuzzleSelectOptions(idx);

    // pyydetty toiminto: "kun uusi pulma tallennetaan niin luodaan heti uusi pulma"
    createNewPuzzle(true);
    setStatus("Tallennettu. Uusi pulma luotu.");
  }

  function deleteCurrentPuzzle(){
    const idx = getCurrentPuzzleIndex();
    if (idx < 0) return;

    if (fileObj.puzzles.length === 1){
      // pidetään aina vähintään 1 pulma
      fileObj.puzzles[0] = { id:"001", name:"Pulma 001", pieces:[] };
      refreshPuzzleSelectOptions(0);
      loadPuzzleToBoard(0);
      setStatus("Pulma tyhjennetty (viimeistä ei poisteta).");
      return;
    }

    fileObj.puzzles.splice(idx, 1);

    // renumeroi id:t siististi 001..N (helpottaa)
    fileObj.puzzles.forEach((p, i) => {
      p.id = String(i+1).padStart(3, "0");
      if (!p.name) p.name = "Pulma " + p.id;
    });

    const newIdx = Math.max(0, idx - 1);
    refreshPuzzleSelectOptions(newIdx);
    loadPuzzleToBoard(newIdx);
    setStatus("Pulma poistettu.");
  }

  // ===== Export / Import =====
  function exportJSON(){
    // Päivitä nykyinen pulma tiedostoon ennen exporttia, vaikka käyttäjä ei olisi painanut "Tallenna".
    const idx = getCurrentPuzzleIndex();
    if (idx >= 0){
      const puz = fileObj.puzzles[idx];
      puz.name = puzNameEl.value.trim() || puz.name;
      puz.pieces = boardToPuzzlePieces();
      puz.metrics = (lastSolveMetrics != null) ? { ...lastSolveMetrics } : (puz.metrics != null ? puz.metrics : null);
      refreshPuzzleSelectOptions(idx);
    }

    const json = JSON.stringify(fileObj, null, 2);
    const blob = new Blob([json], { type:"application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "rattaat_pulmat.json";
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 1000);
    setStatus("JSON ladattu.");
  }

  function importJSON(obj){
    // kevyt validointi
    if (!obj || typeof obj !== "object") { alert("JSON on tyhjä tai väärä."); return; }
    if (!Array.isArray(obj.puzzles)) { alert("JSON: puzzles puuttuu."); return; }

    // hyväksytään, mutta pakotetaan board asetukset tähän peliin
    fileObj = {
      ...FILE_TEMPLATE(),
      ...obj,
      board: { w:5, h:5, bigGears:[10,22] },
      puzzles: obj.puzzles.map((p, i) => ({
        id: (p.id ? String(p.id) : String(i+1).padStart(3,"0")),
        name: (p.name ? String(p.name) : ("Pulma " + String(i+1).padStart(3,"0"))),
        pieces: Array.isArray(p.pieces) ? p.pieces : [],
        metrics: (p.metrics != null) ? p.metrics : null
      }))
    };

    if (fileObj.puzzles.length === 0){
      fileObj.puzzles.push({ id:"001", name:"Pulma 001", pieces:[] });
    }

    // siisti id:t 001..N
    fileObj.puzzles.forEach((p, i) => p.id = String(i+1).padStart(3,"0"));

    refreshPuzzleSelectOptions(0);
    loadPuzzleToBoard(0);
    setStatus("JSON tuotu. Voit muokata ja tallentaa.");
  }



  // ===== Solvability check (uses same rules as index.html) =====
  // - 'x' = gear, 'o' = non-gear occupied, '-' = empty (does NOT block)
  // - Connectivity only N/E/S/W (no diagonals)
  // - Mirror only for r and v (HAS_MIRROR)

function checkSolvableCurrentBoard(){
  // Build fixed masks from currently placed (locked) pieces
  const fixed = buildFixedMasksFromBoard();
  if(!fixed.ok){
    setStatus("❌ Laudalla on päällekkäisyyksiä / virheellinen asettelu.");
    return;
  }

  const remaining = Object.keys(state).filter(pid => !state[pid].placed);
  if(remaining.length === 0){
    // Board already uses all pieces; just validate goal
    const ok = isSolvedMasks(fixed.usedMask, fixed.gearMask);

    // Even if everything is already placed, store a minimal metrics object so
    // exporting/saving doesn't end up with null metrics.
    lastSolveMetrics = {
      solvable: !!ok,
      unique: !!ok,          // if solved, this board-state is a valid solution
      solutions: ok ? 1 : 0,
      nodes: 0,
      backtracks: 0,
      decoys: 0,
      gearAdjacentCandidates: 0,
      firstChoices: null
    };

    // Persist metrics immediately to current puzzle so switching puzzles won't drop them
    const _curIdx = getCurrentPuzzleIndex();
    if(_curIdx >= 0 && fileObj && Array.isArray(fileObj.puzzles) && fileObj.puzzles[_curIdx]){
      fileObj.puzzles[_curIdx].metrics = { ...lastSolveMetrics };
    }

    setStatus(ok ? "✅ Pulma on jo ratkaistu." : "❌ Kaikki palat on asetettu, mutta rataskytkentä puuttuu.");
    return;
  }

  // Precompute placements for each remaining piece (all rotations + allowed mirrors)
  const placementsByPid = new Map();
  for(const pid of remaining){
    placementsByPid.set(pid, precomputePlacements(pid));
  }

  // Ratassopivat asennot: kaikki lailliset asennot (ankkuri × kierto × peilaus),
  // joissa palan ratas (x) koskettaa jompaa kumpaa isoa ratasta (vain vaaka/pysty).
  const idxA = BIG_A_TOUCH.r * W + BIG_A_TOUCH.c;
  const idxB = BIG_B_TOUCH.r * W + BIG_B_TOUCH.c;
  const touchBits = (1 << idxA) | (1 << idxB);

  let gearAdjacentCandidates = 0;
  for(const pid of remaining){
    const all = placementsByPid.get(pid) || [];
    for(const pl of all){
      if((pl.occMask & fixed.usedMask) !== 0) continue;     // ei saa törmätä lukittuihin
      if((pl.gearMask & touchBits) === 0) continue;         // ei kosketa isoa ratasta
      gearAdjacentCandidates++;                              // tämä asento kelpaa aloitus-kandidaatiksi
    }
  }

  const fixedPlaced = Object.keys(state).filter(pid => !!state[pid].placed).length;

  const limit = 2; // count up to 2 (0,1,2+)
  const res = dfsCountSolutionsWithStats(
    fixed.usedMask,
    fixed.gearMask,
    remaining,
    placementsByPid,
    limit,
    fixedPlaced
  );

  const count = res.found;
  const st = res.stats;


  // Store metrics so they can be saved into the puzzle JSON on next Save/Export
  lastSolveMetrics = {
    solvable: count > 0,
    unique: count === 1,
    solutions: count,
    nodes: st.nodes,
    backtracks: st.backtracks,
    decoys: st.deadEnds,
    gearAdjacentCandidates: gearAdjacentCandidates,
    firstChoices: (st.firstChoices == null ? null : st.firstChoices)
  };

  // Persist metrics immediately to current puzzle so switching puzzles won't drop them
  const _curIdx2 = getCurrentPuzzleIndex();
  if(_curIdx2 >= 0 && fileObj && Array.isArray(fileObj.puzzles) && fileObj.puzzles[_curIdx2]){
    fileObj.puzzles[_curIdx2].metrics = { ...lastSolveMetrics };
  }

  const lines = [];

  if(count <= 0){
    lines.push("❌ Ei ratkaisua (0 kpl)");
  }else if(count === 1){
    lines.push("✅ Löytyi ratkaisu (uniikki)");
    lines.push("   (1 kpl)");
  }else{
    lines.push("✅ Löytyi useampi ratkaisu");
    lines.push("   (2+ kpl)");
  }

  lines.push("");           // tyhjä rivi selkeyden vuoksi
  lines.push("Mittarit:");
  lines.push(`• Solmut: ${st.nodes}`);
  lines.push(`• Backtrackit: ${st.backtracks}`);
  lines.push(`• Näennäisratkaisut: ${st.deadEnds}`);
  lines.push(`• Ratassopivat asennot: ${gearAdjacentCandidates}`);																  
  lines.push(`• Alkuhaarat: ${st.firstChoices == null ? "-" : st.firstChoices}`);

  setStatus(lines.join("\n"));
}


  function buildFixedMasksFromBoard(){
    let usedMask = 0;
    let gearMask = 0;

    for(const pid of Object.keys(state)){
      const pl = state[pid].placed;
      if(!pl) continue;

      const base = parseBaseShape(PIECES[pid]);
      const tr = transformOcc(base, state[pid].rot, state[pid].mir);

      for(const p of tr.pts){
        const r = pl.anchorR + p.y;
        const c = pl.anchorC + p.x;
        if(r < 0 || c < 0 || r >= H || c >= W) return { ok:false };
        const idx = r*W + c;
        const bit = 1 << idx;
        if(usedMask & bit) return { ok:false };
        usedMask |= bit;
        if(p.gear) gearMask |= bit;
      }
    }

    return { ok:true, usedMask, gearMask };
  }

  function precomputePlacements(pid){
    const base = parseBaseShape(PIECES[pid]);

    const mirrors = HAS_MIRROR.has(pid) ? [false, true] : [false];
    const rots = [0, 90, 180, 270];

    const out = [];
    const seen = new Set();

    for(const mir of mirrors){
      for(const rot of rots){
        const tr = transformOcc(base, rot, mir);

        // Dedup identical shapes (symmetries)
        const sigPts = tr.pts
          .slice()
          .sort((a,b)=> (a.y-b.y) || (a.x-b.x) || ((a.gear?1:0)-(b.gear?1:0)))
          .map(p => `${p.x}:${p.y}:${p.gear?1:0}`)
          .join('|');
        const sig = `${tr.w}x${tr.h}|${sigPts}`;
        if(seen.has(sig)) continue;
        seen.add(sig);

        for(let anchorR=0; anchorR<=H-tr.h; anchorR++){
          for(let anchorC=0; anchorC<=W-tr.w; anchorC++){
            let occMask = 0;
            let gMask = 0;
            for(const p of tr.pts){
              const r = anchorR + p.y;
              const c = anchorC + p.x;
              const idx = r*W + c;
              const bit = 1 << idx;
              occMask |= bit;
              if(p.gear) gMask |= bit;
            }
            out.push({ pid, rot, mir, anchorR, anchorC, occMask, gearMask:gMask });
          }
        }
      }
    }

    return out;
  }

  function dfsCountSolutionsWithStats(usedMask, gearMask, remaining, placementsByPid, limit, fixedPlaced){
    const stats = {
      nodes: 0,
      backtracks: 0,
      deadEnds: 0,
      firstChoices: null,
      solutionDepth: null
    };

    // Track when the big gears become connected along the current branch.
    function dfs(usedMask, gearMask, remaining, limit, connectedAt){
      if(limit <= 0) return 0;
      stats.nodes++;

      if(remaining.length === 0){
        if(isSolvedMasks(usedMask, gearMask)){
          if(stats.solutionDepth == null && connectedAt != null) stats.solutionDepth = connectedAt;
          return 1;
        }
        stats.deadEnds++;
        return 0;
      }

      // MRV: pick the piece with least compatible placements
      let bestPid = null;
      let bestList = null;
      let bestCount = Infinity;

      for(const pid of remaining){
        const all = placementsByPid.get(pid) || [];
        // filter by collision
        let cnt = 0;
        for(const pl of all){
          if((pl.occMask & usedMask) === 0) cnt++;
          if(cnt >= bestCount) break;
        }
        if(cnt === 0) return 0;
        if(cnt < bestCount){
          bestCount = cnt;
          bestPid = pid;
          bestList = all;
          if(bestCount === 1) break;
        }
      }

      const nextRemaining = remaining.filter(p => p !== bestPid);

      // simple ordering: try placements that add gears earlier (helps)
      const ordered = bestList.slice().filter(pl => (pl.occMask & usedMask) === 0);
      ordered.sort((a,b) => {
        const ga = popcount32(a.gearMask);
        const gb = popcount32(b.gearMask);
        return gb - ga;
      });

      // Record initial branching (once)
      if(stats.firstChoices == null){
        stats.firstChoices = ordered.length;
      }

      let found = 0;
      for(const pl of ordered){
        const newUsed = usedMask | pl.occMask;
        const newGear = gearMask | pl.gearMask;

        // Detect when big gears become connected along this branch.
        let newConnectedAt = connectedAt;
        if(newConnectedAt == null){
          const idxA = BIG_A_TOUCH.r * W + BIG_A_TOUCH.c;
          const idxB = BIG_B_TOUCH.r * W + BIG_B_TOUCH.c;
          const bitA = 1 << idxA;
          const bitB = 1 << idxB;
          if((newGear & bitA) && (newGear & bitB) && gearConnected(newGear, idxA, idxB)){
            // remaining[] contains only NOT-yet-placed pieces (fixed pieces are excluded from it),
            // so total placed so far = totalPieces(7) - remainingCount.
            const placedSoFar = 7 - nextRemaining.length;
            newConnectedAt = placedSoFar;
          }
        }

        found += dfs(newUsed, newGear, nextRemaining, limit - found, newConnectedAt);
        if(found >= limit) return found;
      }

      if(found === 0) stats.backtracks++;
      return found;
    }

    const found = dfs(usedMask, gearMask, remaining, limit, null);
    return { found, stats };
  }

  function popcount32(x){
    // x is <= 2^25 so fits in 32-bit
    x = x - ((x >>> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
    return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
  }

  function isSolvedMasks(usedMask, gearMask){
    // must use all pieces (i.e. occupy exactly 25? no, board can have empty spots because '-' holes)
    // But rule from index.html: all 7 pieces must be placed.
    // Here we are in leaf where remaining==0, so ok.

    const idxA = BIG_A_TOUCH.r * W + BIG_A_TOUCH.c;
    const idxB = BIG_B_TOUCH.r * W + BIG_B_TOUCH.c;
    const bitA = 1 << idxA;
    const bitB = 1 << idxB;

    if((gearMask & bitA) === 0) return false;
    if((gearMask & bitB) === 0) return false;

    return gearConnected(gearMask, idxA, idxB);
  }

  function gearConnected(gearMask, startIdx, goalIdx){
    const q = [startIdx];
    const seen = new Set([startIdx]);

    while(q.length){
      const cur = q.shift();
      if(cur === goalIdx) return true;
      const r = Math.floor(cur / W);
      const c = cur % W;
      const nbr = [
        [r-1,c], [r+1,c], [r,c-1], [r,c+1]
      ];
      for(const [rr,cc] of nbr){
        if(rr<0||cc<0||rr>=H||cc>=W) continue;
        const ni = rr*W + cc;
        if(seen.has(ni)) continue;
        const bit = 1 << ni;
        if((gearMask & bit) === 0) continue;
        seen.add(ni);
        q.push(ni);
      }
    }
    return false;
  }

  // ===== UI helpers =====
  function refreshCounts(){
    const placed = Object.keys(state).filter(pid => !!state[pid].placed).length;
    countEl.textContent = `${placed}/7`;
    // status label stays in statusEl
  }

  function setStatus(txt){
    statusEl.textContent = txt;
  }
})();
</script>
</body>
</html>
